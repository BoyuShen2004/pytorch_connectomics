# NucMM Zebrafish nucleus segmentation with MONAI Residual UNet
# Multi-task learning: Binary + Contour + Distance
#
# This config uses MONAI's UNet with residual units for nucleus segmentation
# with multi-task learning to predict:
#   - Channel 0: Binary masks (sigmoid activation)
#   - Channel 1: Contour maps (sigmoid activation) 
#   - Channel 2: Distance transforms (tanh activation)
#
# Based on NucMM-Zebrafish-UNet-BCD.yaml configuration from pytorch_connectomics_v1.
# The multi-task setup uses different loss functions for each channel:
#   - Binary & Contour: DiceLoss + BCEWithLogitsLoss
#   - Distance: WeightedMSE

experiment_name: nucmm_zebrafish_monai_unet
description: Zebrafish nucleus segmentation on NucMM dataset using MONAI Residual UNet with multi-task learning

# System
system:
  training:
    num_gpus: 1
    num_cpus: 1
    num_workers: 1
    batch_size: 4
  inference:
    num_gpus: 1
    num_cpus: 1
    num_workers: 1
    batch_size: 4
  seed: 42

# Model - MONAI UNet with residual units for multi-task learning
model:
  architecture: monai_unet
  input_size: [32, 96, 96]
  output_size: [32, 96, 96]
  in_channels: 1
  out_channels: 3                      # 3 channels: binary, contour, distance

  # UNet architecture configuration
  filters: [32, 64, 96, 128, 160]     # NucMM-specific channel progression
  num_res_units: 2                     # Residual units per block
  kernel_size: 3                       # Convolution kernel size
  norm: batch
  dropout: 0.0                         # No dropout for nucleus segmentation

  # Multi-task loss configuration
  loss_functions: [DiceLoss, BCEWithLogitsLoss, WeightedMSE]
  loss_weights: [1.0, 0.5, 2.0]       # Binary: Dice+BCE, Contour: Dice+BCE, Distance: MSE
  loss_kwargs:
    - {sigmoid: true, smooth_nr: 1e-5, smooth_dr: 1e-5}  # DiceLoss for binary
    - {}                                 # BCEWithLogitsLoss for binary
    - {}                                 # WeightedMSE for distance

  # Multi-task configuration
  # Format: [[start_ch, end_ch, target_name, loss_indices], ...]
  multi_task_config:
    - [0, 1, "label", [0, 1]]          # Original labels: Dice + BCE
    - [1, 2, "boundary", [0, 1]]       # Boundary channel: Dice + BCE  
    - [2, 3, "edt", [2]]               # Distance channel: MSE

# Data - NucMM Zebrafish dataset
data:
  # Volume configuration
  train_image: datasets/NucMM-Z/Image/train/img_0000_0576_0768.h5
  train_label: datasets/NucMM-Z/Label/train/seg_0000_0576_0768.h5
  val_image: datasets/NucMM-Z/Image/val/img_0000_0640_0832.h5.h5
  val_label: datasets/NucMM-Z/Label/val/seg_0000_0640_0832.h5.h5  
  train_resolution: [1.0, 1.0, 1.0]   # NucMM: 1.0 isotropic resolution
  use_preloaded_cache: true            # Load volumes into memory for fast training

  # Patch configuration
  patch_size: [32, 96, 96]             # NucMM-specific patch size
  pad_size: [16, 32, 32]               # Padding for valid convolutions
  iter_num_per_epoch: 128           # Large number of iterations per epoch
  
  # Image normalization
  image_transform:
    normalize: "0-1"                   # Min-max normalization to [0, 1]
    clip_percentile_low: 0.0           # No clipping
    clip_percentile_high: 1.0

  # Label transformation for multi-task learning
  label_transform:
    targets:
      - name: binary                # Channel 0: foreground mask
      - name: instance_boundary     # Channel 1: contour map
        kwargs:
          thickness: 1
          do_bg: false
          do_convolve: false
      - name: instance_edt          # Channel 2: distance transform
        kwargs:
          mode: "2d"
          quantize: false

  # Augmentation
  augmentation:
    enabled: true

# Optimizer - AdamW with NucMM-specific hyperparameters
optimization:
  max_epochs: 1000
  gradient_clip_val: 1.0
  accumulate_grad_batches: 1
  precision: "bf16-mixed"              # BFloat16 mixed precision
  
  optimizer:
    name: AdamW
    lr: 0.02                           # Higher LR for NucMM (from original config)
    weight_decay: 0.01
    betas: [0.9, 0.999]
    eps: 1.0e-8

  # Scheduler - Cosine annealing with warmup
  scheduler:
    name: CosineAnnealingLR
    warmup_epochs: 10
    warmup_start_lr: 1.0e-4
    min_lr: 1.0e-6
    t_max: 950

monitor:
  # Loss monitoring and validation frequency  
  detect_anomaly: false
  logging:
    # scalar loss
    scalar:
      loss: [train_loss_total_epoch]
      loss_every_n_steps: 10
      val_check_interval: 1.0
      benchmark: true
    
    # visualization
    images:
      enabled: true
      max_images: 8
      num_slices: 2
      log_every_n_epochs: 1
      channel_mode: all                 # Show all 3 channels for multi-task
      selected_channels: null
  
  # Checkpointing
  checkpoint:
    mode: min
    save_top_k: 1
    save_last: true
    save_every_n_epochs: 10
    dirpath: outputs/nucmm_zebrafish_monai_unet/checkpoints/
    use_timestamp: true

  # Early stopping
  early_stopping: 
    enabled: true
    monitor: train_loss_total_epoch
    patience: 300
    mode: min
    min_delta: 1.0e-5
    check_finite: true
    threshold: 0.01
    divergence_threshold: 2.0

# Inference - MONAI SlidingWindowInferer for NucMM
inference:
  data:
    test_image: datasets/NucMM-Z/Image/val/img_0000_0640_0896.h5
    test_label: datasets/NucMM-Z/Label/val/seg_0000_0640_0896.h5
    test_resolution: [1.0, 1.0, 1.0]
    output_path: outputs/nucmm_zebrafish_monai_unet/results/

  # MONAI SlidingWindowInferer parameters
  sliding_window:
    window_size: [33, 257, 257]        # NucMM inference window size
    sw_batch_size: 4                   # Number of patches processed simultaneously
    overlap: 0.5                       # 50% overlap between patches
    blending: gaussian                 # Gaussian weighting for smooth blending
    sigma_scale: 0.25
    padding_mode: reflect              # Reflection-padding at volume boundaries

  # Test-Time Augmentation (TTA)
  test_time_augmentation:
    enabled: true
    flip_axes: null                    # No augmentation for NucMM
    act: sigmoid                       # Primary activation (binary segmentation)
    select_channel: null               # Use all channels
    ensemble_mode: mean

  # Postprocessing configuration
  postprocessing:
    output_scale: 255
    output_dtype: uint8

  # Evaluation
  evaluation:
    enabled: true
    metrics: [jaccard, dice]           # Multiple metrics for nucleus segmentation
